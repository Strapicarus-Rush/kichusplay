#include <GLFW/glfw3.h>
#include <SFML/Audio.hpp>
#include <iostream>
#include <string>
#include <thread>
#include <chrono>

// Include stb_image library for image loading
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// Include tinygltf for GLTF model loading
#define TINYGLTF_IMPLEMENTATION
#include "tiny_gltf.h"

enum class GameState {
    MENU,
    GAMEPLAY
};

// Function to load an image using stb_image
unsigned char* loadImage(const char* filename, int& width, int& height, int& channels) {
    stbi_set_flip_vertically_on_load(true); // Flip loaded image vertically to match OpenGL's coordinate system
    return stbi_load(filename, &width, &height, &channels, STBI_rgb_alpha);
}

// Function to initialize GLFW and create a window
GLFWwindow* initWindow(int width, int height, const char* title) {
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return nullptr;
    }

    // Set GLFW options (optional)
    // glfwWindowHint(GLFW_SAMPLES, 4); // 4x antialiasing
    // glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // We want OpenGL 3.3
    // glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // We don't want the old OpenGL

    // Create a windowed mode window and its OpenGL context
    GLFWwindow* window = glfwCreateWindow(width, height, title, NULL, NULL);
    if (!window) {
        std::cerr << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return nullptr;
    }

    // Make the window's context current
    glfwMakeContextCurrent(window);

    // Enable v-sync
    glfwSwapInterval(1);

    return window;
}

void renderImage(unsigned char* data, int width, int height, int windowWidth, int windowHeight) {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, windowWidth, windowHeight, 0, -1, 1); // Set up orthographic projection with origin at top-left

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear the framebuffer

    // Calculate the size of the image based on the window size
    int imageSize = std::min(windowWidth, windowHeight) / 2;

    // Calculate the position to center the image
    int x = (windowWidth - imageSize) / 2;
    int y = (windowHeight - imageSize) / 2;

    // Render the image as a textured quad
    glEnable(GL_TEXTURE_2D);
    GLuint texID;
    glGenTextures(1, &texID);
    glBindTexture(GL_TEXTURE_2D, texID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

    glBegin(GL_QUADS);
    glTexCoord2f(0, 0); glVertex2f(x, y);
    glTexCoord2f(-1, 1); glVertex2f(x + imageSize, y);
    glTexCoord2f(1, 1); glVertex2f(x + imageSize, y + imageSize);
    glTexCoord2f(1, -1); glVertex2f(x, y + imageSize);
    glEnd();

    glDeleteTextures(1, &texID); // Clean up texture

    glDisable(GL_TEXTURE_2D);
}

// Function to render a GLTF model
void renderModel(const tinygltf::Model& model) {
    // Render the GLTF model
    // You need to implement rendering of the GLTF model based on the loaded data
    // This may involve rendering meshes, materials, and textures from the model
    // Consult the documentation of your GLTF loader library for details on rendering
}

void error_callback(int error, const char* description)
{
    fprintf(stderr, "Error: %s\n", description);
}

int main() {
    //Required minimum OpenGL version
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    const int WIDTH = 800;
    const int HEIGHT = 600;
    const char* TITLE = "KichusPlay | By Strapicarus";

    // Initialize GLFW and create window
    GLFWwindow* window = initWindow(WIDTH, HEIGHT, TITLE);
    if (!window) return -1;

    // Load image
    int imageWidth, imageHeight, imageChannels;
    unsigned char* imageData = loadImage("logo.png", imageWidth, imageHeight, imageChannels);
    if (!imageData) {
        std::cerr << "Failed to load image" << std::endl;
        glfwTerminate();
        return -1;
    }

    // Main loop
    while (!glfwWindowShouldClose(window)) {
	// Get window size
        int windowWidth, windowHeight;
        glfwGetFramebufferSize(window, &windowWidth, &windowHeight);
        // Render
        glClear(GL_COLOR_BUFFER_BIT);

        // Draw image in the center
        //int x = (WIDTH - imageWidth) / 2;
        //int y = (HEIGHT - imageHeight) / 2;
        renderImage(imageData, imageWidth, imageHeight, windowWidth, windowHeight);

        // Swap buffers and poll events
        glfwSwapBuffers(window);
        glfwPollEvents();

        // Sleep for a short duration to limit the frame rate
        std::this_thread::sleep_for(std::chrono::milliseconds(16)); // ~60 fps
    }

    // Clean up
    stbi_image_free(imageData);
    glfwTerminate();
    return 0;
}
